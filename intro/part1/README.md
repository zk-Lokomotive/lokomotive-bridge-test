# Intro to Wormhole - Part 1

## Prerequisites

### EVM / UI

[Node.js](https://nodejs.org/en/)

### Solana

```bash
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
rustup default nightly-2021-08-01
curl https://rustwasm.github.io/wasm-pack/installer/init.sh -sSf | sh
sh -c "$(curl -sSfL https://release.solana.com/v1.8.1/install)"
```

Actually:

```bash
rustup default nightly
```

Works instead of nightly-2021-08-01
And in messenger_solana_bg.js following code needs to commented out for now:

```
    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_systeminstruction_free(ptr);
    }
```

restart your terminal or run the provided export command

## Setup

Start a [minimal_devnet](../../../minimal_devnet/)

Deploy the EVM contracts

```bash
cd ethereum
npm ci
npm run build
npm run migrate
```

Deploy the Solana contracts and generate wasm (for UI)

```bash
cd solana
EMITTER_ADDRESS="11111111111111111111111111111115" cargo build-bpf
# if running the local (tilt) devnet
# if kubectl was not found - use "minikube kubectl -- " in place of "kubectl "
kubectl cp -c devnet target/deploy/messenger_solana.so solana-devnet-0:/usr/src/
kubectl cp -c devnet id.json solana-devnet-0:/usr/src/
kubectl exec -c devnet solana-devnet-0 -- solana program deploy -u l --output json -k /usr/src/id.json /usr/src/messenger_solana.so > ../ui/src/contract-addresses/solana.json
# else if running the minimal-devnet
solana program deploy -u l --output json -k id.json target/deploy/messenger_solana.so > ../ui/src/contract-addresses/solana.json
# Generate wasm for JS code (Tilt and minimal-devnet)
EMITTER_ADDRESS="11111111111111111111111111111115" wasm-pack build --target bundler -d bundler -- --features wasm
```

Run the UI

```bash
cd ui
npm ci
npm run typechain
npm start
```

## Tech

### Chain side

The Ethereum smart contract is in
`ethereum/contracts/Messenger.sol`
It simply posts received string to the wormhole network

```
    function sendStr(bytes memory str, uint32 nonce) public returns (uint64 sequence) {
        sequence = _wormhole.publishMessage(nonce, str, 1);
        return sequence;
    }
```

`IWormhole.publishMessage` finction is part of wormhole SDK. Last argument is consistency level. It tells Wormhole how many blocks to go before the message is approved (VAA-ed). We use 1 here to get response faster. In production 15 is used.
Wormhole smart contract address on chain is known and is hardcoded into this example.

### Client side

Calling code is in
`ui/src/App.tsx`
`sendClickHandler` is function which sends a string message to the Messenger contract, and then waits for Wormhole to sign VAA generated by Messenger. We then use returned sequence number and our originator chainId to tell Wormhole which VAA we're looking for. Using this data - we then wait and retrieve retrieve VAA from Wormhole using SDK `getSignedVAAWithRetry` call. Now this VAA is signed, and is good to be used on another Wormhole connected chain! That will be done in Part2.
